---
theme : "night"
transition: "slide"
highlightTheme: "vs"
slideNumber: true
---
<style type="text/css">
  .reveal pre code {
    font-size: 1em;
    line-height: 1.2;
    height: 200%;
    max-height: 1000% !important;
  }
  .reveal section p {
    display: inline-block;
    font-size: 0.9em;
    line-height: 1em;
    vertical-align: top;
  }

  .reveal section li {
    font-size: 0.9em;
    line-height: 1em;
    vertical-align: top;
  }

  .reveal section table {
    display: inline-block;
    font-size: 0.7em;
    line-height: 1.2em;
    vertical-align: top;
  }

</style>

#### Сибирь I
## Память
#### и вновь немного ООП

--

### Опять работа
Нужно написать свой `string`

--

#### В предыдущих сериях

--

### Виды памяти
- `static` -- _хранилище глобальных переменных_
- `stack` -- _хранилище локальных переменных (и не только)_
- `heap` -- _динамическая память (много памяти)_

--

### Зачем оно вообще нужно?

--

### Лучше один раз увидеть

--

<img src=/src/cumburger.png>

--

<img src=/src/another-picture.jpg width=65%>

--

![](/src/data-scheme.png)

---

Микромемчик

<img src=/src/cat.jpg width=400>

--

## static memory
- Существует в течение всего времени работы программы
- Переменные являются статическими, существуют в единственном экземпляре и доступны в любом месте программы

--

## stack memory
- Контролируется CPU
- С его помощью программа вообще работает
- Переменые являются локальными
- С изменением количества переменных меняется и стек
- Стек не бесконечен

--

### Проверяем остаточные знания
Какова длительность "жизни" локальных переменных?

--

<img src=/src/local.jpg width=600>

--

## heap memory
- Контролируется программистом
- `new` и `delete` --  наше всё
- Для доступа требуются указатели
- Как правило ограничивается количеством доступной физической памяти

--

указатели

---

### Указатель
>Это тип данных, в котором хранится адрес памяти объекта (число)

--

### Не путать с ссылками!
>Ссылка -- альтернативное имя переменной

--

### Примеры
```cpp
int* p = new int(17);  // создаём объект
std::cout << *p << std::endl;
delete p;  // удаляем объект

int* arr = new int[n];  // выделяем область памяти
for (size_t i; i < n; ++i) {  // докупаем
  p[i] = 0;
}
delete[] arr;  // фиксируем прибыль
```

--

### Заметили ошибку?

--


<img src=/src/pointers.webp width=60%>

--

#### Одним измерением и ограничимся?

--

```cpp
int** arr = new int*[n2];  // создаём указатель на указатель
for (size_t i; i < n2; ++i) { 
  arr[i] = new int[n1]();  // выделяем память
}

for (size_t i; i < n2; ++i) {  // освобождаем в том же порядке
  delete[] arr[i];             // что и выделяли
}
delete[] arr;
```

--

### Двумя измерениями и ограничимся?

--

![](/src/pointer-ception.png)

--

## Трёх измерений нам достаточно?

--

![](/src/pointer-pointer.png)

--

### И как с этим жить?

---

### Немного забегаем вперёд

--

### Конструкторы и деструкторы
- **Конструктор** -- _блок операторов, служащий для инициализации объекта, имя совпадает с именем класса_
- **Деструктор** -- _блок операторов, служащий для уничтожения объекта, в классах выглядит:_

`~ClassName`

--

### RAII
>Resourse Acquisition is Initialisation 

>Получение некоторого ресурса неразрывно совмещается с инициализацией, а освобождение -- с уничтожением объекта

--

### Пользуемся не только конструкторами

--

### `std::unique_ptr`
Облегчает работу с указателями

```cpp
{
  {
    std::unique_ptr<int[]> vec_ptr(new int[3]{1, 2, 3});
    std::cout << vec_ptr[0] << vec_ptr[1] << std::endl;
  }
  // vec_ptr очищен
  ...
}
```

Осуществляет единственное владение!

---

![](/src/void-pointer.jpg)
